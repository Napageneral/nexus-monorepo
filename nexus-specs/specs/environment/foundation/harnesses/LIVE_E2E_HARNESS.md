# Live E2E Harness Specification (Real LLM)

**Status:** ACTIVE
**Last Updated:** 2026-02-17
**Canonical Lifecycle Spec:** `specs/environment/foundation/WORKSPACE_LIFECYCLE.md`

## Purpose

Define the scope and expansion plan for a **live** end-to-end (E2E) harness that:

1. Creates a fresh Nexus workspace via `nexus init`.
2. Starts a real Nexus runtime via `nexus start`.
3. Sends messages through the runtime (`chat.send` / NEX pipeline) in MWP mode.
4. Uses **real provider auth** (no deterministic model mocking).
5. Validates persistence and debuggability via the ledgers and automation invocation records.

The workspace lifecycle contract (init, boot, onboarding, credentials, automations) is defined in `WORKSPACE_LIFECYCLE.md`. This document defines the **harness scenarios and assertions** that validate that contract.

## Non-Goals

- Deterministic unit-testing of model behavior.
- Smart routing / smart forking completeness (out of scope for the first E2E milestone).

## Constraints / Principles

- **Real LLM calls**: no mock providers in the primary harness.
- **Headless auth**: harness uses the token generated by `nexus init` — no manual patching.
- **Always MWP**: the system runs in Manager-Worker Pattern mode from the first message. No unified mode.
- **Durable ingest ACK**: `chat.send` ACKs only after NEX ingest completes (post-`receiveEvent` ledger write); remaining pipeline runs async.
- **Failure persistence**: any failure must be recorded in `nexus_requests` with stage, message, stack, snapshot.
- **AGENTS.md is workspace-level**: MWP role prompts/tools are decided during context assembly based on the Broker role, not embedded into `AGENTS.md`.

## Clarification Workplan (Bundled)

The 7 original clarification items are grouped into 3 bundles. Bundle A is **resolved** — see `WORKSPACE_LIFECYCLE.md`.

### Bundle A: Workspace Lifecycle (Items 1, 2, 6, 7) — RESOLVED

All decisions captured in `specs/environment/foundation/WORKSPACE_LIFECYCLE.md`:

- **Item 1 (`nexus init` contract):** Init creates all dirs, all 5 DBs (eagerly, with schema), generates auth token, writes config to `state/config.json`. Flat `skills/` dir. `BOOTSTRAP.md` is permanent.
- **Item 2 (onboarding identity + completion):** Always MWP. Bootstrap detected by absence of agent persona dirs in `state/agents/`. `BOOTSTRAP.md` content injected into MA system prompt. Identity files at `state/agents/{name}/IDENTITY.md` + `SOUL.md`, `state/user/IDENTITY.md`. Completion = persona dir exists with `IDENTITY.md`.
- **Item 6 (credential scan):** External CLI auto-sync at runtime startup. Agent-driven env var scan during onboarding (MA dispatches worker). `BOOTSTRAP.md` template instructs MA to do this.
- **Item 7 (default automations):** Ships memory-reader, memory-writer, command-logger, boot-md. Seeded at runtime startup. Workspaces at `state/workspace/{name}/`. Legacy `session-memory` and `soul-evil` dropped.

### Bundle B: Runtime Routing (Items 3, 4) — PENDING

**Theme:** How messages flow once the workspace is alive.

Items: 3 (session keys + routing), 4 (adapters-only runtime)

### Bundle C: Optional Runtime Surfaces (Item 5) — PENDING

**Theme:** Canvas host and browser control — are they first-class or opt-in?

Items: 5 (canvas host + browser control)

---

## Current Reference Implementation (Code)

- Live harness script: `nex/scripts/dev/nexus-e2e-live.ts`
- Runtime startup: `nex/src/nex/control-plane/server-startup.ts`
- Readiness: `nex/src/nex/control-plane/server-http.ts`
- `chat.send` ingest: `nex/src/nex/control-plane/server-methods/chat.ts`
- Init command: `nex/src/commands/init.ts`
- Context assembly: `nex/src/nex/stages/assembleContext.ts`
- Automations runtime: `nex/src/nex/automations/hooks-runtime.ts`
- Automations DB: `nex/src/db/hooks.ts`
- Memory reader/writer: `nex/src/nex/automations/meeseeks/memory-reader.ts`, `memory-writer.ts`

## Harness Interface

Script: `nex/scripts/dev/nexus-e2e-live.ts`

### Inputs

- `--binary <path>`: `nexus` CLI to execute (default: `nexus` on PATH)
- `--workspace-root <dir>`: where to create the fresh workspace (default: temp dir)
- `--runtime-port <port>`: runtime port to use (default: pick a free port)
- `--max-turns <n>`: number of onboarding turns to send (default: 3)
- `--timeout-ms <ms>`: trace completion timeout (default: 180s)
- `--health-timeout-ms <ms>`: readiness timeout (default: 30s)
- `--keep`: keep the workspace dir for inspection
- `--cleanup-on-fail`: cleanup only when passing

Note: `--runtime-token` is no longer needed — init generates it. The harness reads it from `state/config.json`. Auth profile copying flags are no longer needed — external CLI sync happens at runtime startup.

### Outputs

- JSON summary (printed to stdout)
- `runtime.log` written into the workspace root
- A kept workspace (when `--keep` or when failures require inspection)

---

## E2E Harness Scenarios

Each scenario is chat-driven (messages sent to the runtime) and validated by reading ledgers + runtime logs + filesystem state.

### Validation Sources

- `state/data/events.db` — inbound + outbound event records
- `state/data/agents.db` — sessions, turns, messages, tool_calls, queue_items
- `state/data/identity.db` — identity mappings
- `state/data/nexus.db` — `nexus_requests` trace rows, `automations` table
- `state/cortex/cortex.db` — entities, observations, episodes
- `runtime.log` — startup logs, crashes, warnings
- Filesystem — `state/agents/`, `state/user/`, `state/workspace/`, `state/credentials/`

### Scenario 1: Init + Runtime Boot

1. Create workspace in a temp dir.
2. Run `nexus init`.
3. **Assert post-init state:**
   - Directory structure matches `WORKSPACE_LIFECYCLE.md` Phase 1
   - `state/config.json` has `runtime.auth.token` (non-empty)
   - All 5 DB files exist
   - `state/agents/BOOTSTRAP.md` exists
   - `state/workspace/` is empty
   - `state/user/` is empty
4. Start runtime: `nexus start --workspace <dir> --port <free-port>`
5. Wait for `/health` 200.
6. **Assert post-boot state:**
   - At least one provider credential exists (from external CLI sync)
   - Owner entity exists in cortex
   - Automations table has: `memory-reader`, `memory-writer`, `command-logger`, `boot-md`
   - `state/workspace/memory-reader/` and `state/workspace/memory-writer/` exist with seed files

### Scenario 2: Onboarding Conversation (MWP)

1. Send onboarding chat message via `chat.send`.
2. Wait for MA response (includes worker dispatch).
3. Send follow-up messages as needed for identity conversation (max-turns).
4. **Assert post-onboarding state:**
   - At least one agent persona dir exists: `state/agents/{name}/`
   - `state/agents/{name}/IDENTITY.md` exists and is non-template
   - `state/agents/{name}/SOUL.md` exists and is non-template
   - `state/user/IDENTITY.md` exists and is non-template
   - `state/agents/BOOTSTRAP.md` still exists (NOT deleted)
   - Credential scan trace exists in `nexus_requests`
   - MA dispatched >= 1 worker (check agents ledger for worker turns)
   - `needsBootstrap()` returns false
   - `isOnboarded()` returns true

### Scenario 3: Post-Onboarding MWP Smoke

1. Send one normal chat request (post-onboarding).
2. Wait for MA response.
3. **Assert:**
   - MA context assembly includes agent persona (IDENTITY.md + SOUL.md in system prompt)
   - MA dispatched >= 1 worker via `agent_send op=dispatch`
   - Worker turn recorded in agents ledger
   - Worker returned result to MA
   - MA produced user-facing reply
   - Memory-reader fired at `worker:pre_execution` (check automation invocations)
   - Memory-writer fired at `after:runAgent` (check automation invocations)

### Scenario 4: Queue Semantics (Extended)

- Fire N inbound events quickly.
- Assert `interrupt`/`steer` and `collect` behavior per `specs/runtime/broker/QUEUE_MANAGEMENT.md`.

### Scenario 5: Adapter E2E (Extended)

- Configure EVE adapter for fresh workspace.
- Ingest inbound message via adapter → NEX.
- Assert identity resolution, permissions, broker dispatch, adapter delivery.

### Scenario 6: Operational Artifacts + Debuggability (Extended)

- On any failure, assert:
  - `nexus_requests` row exists with stage, message, stack, snapshot
  - Runtime log is retained
  - Optional: exported request artifact bundles

---

## Phased Workplan

Phases are ordered for maximum leverage.

### Phase 0: Align Init + Boot With WORKSPACE_LIFECYCLE Spec

Goal: `nexus init` produces a workspace matching the spec. Runtime boots cleanly from it without patching.

Changes:
- Update `init.ts` per `WORKSPACE_LIFECYCLE.md` Phase 1
- Update `server-startup.ts` per `WORKSPACE_LIFECYCLE.md` Phase 2
- Update harness script to remove token patching, auth copy flags

### Phase 1: Onboarding MWP (Bootstrap Detection + Context Injection)

Goal: First `chat.send` runs in MWP mode. MA gets BOOTSTRAP.md injected. Dispatches workers. Creates identity files.

Changes:
- Update `assembleContext.ts`: replace unified bootstrap with `needsBootstrap()` + BOOTSTRAP.md injection
- Remove all unified-mode-forcing logic
- Write `BOOTSTRAP.md` onboarding template
- Harness sends onboarding messages, validates identity file creation

### Phase 2: Credential Scan + External CLI Sync

Goal: Runtime auto-syncs external CLIs at startup. Onboarding conversation includes credential scan worker dispatch.

Changes:
- Add external CLI sync to startup sequence
- `BOOTSTRAP.md` template includes credential scan dispatch instructions
- Harness validates provider credentials exist post-boot and scan trace exists post-onboarding

### Phase 3: Default Automations Seeding + Validation

Goal: Memory-reader, memory-writer, command-logger, boot-md seeded at startup. Memory automations fire during MWP conversations.

Changes:
- Add automation seeder to startup sequence
- Move bundled automations to `nex/src/nex/automations/bundled/`
- Harness validates automation rows exist, workspace dirs created, invocations recorded

### Phase 4: Adapters-Only Runtime Cleanup

Goal: Remove legacy channels, gmail-watcher, cron from startup. Adapters-only.

### Phase 5: Queue Semantics E2E

Goal: Validate interrupt/steer/collect behavior under concurrent inbound events.

### Phase 6: Adapter E2E (EVE)

Goal: Prove adapter ingest → identity → permissions → broker → adapter deliver.

### Phase 7: Observability / Artifact Export

Goal: Make failures debug-friendly by default.

---

## Canonical Specs

Workspace lifecycle:
- `specs/environment/foundation/WORKSPACE_LIFECYCLE.md` **(primary, canonical)**

Environment:
- `specs/environment/foundation/WORKSPACE_SYSTEM.md`
- `specs/environment/foundation/INIT_REFERENCE.md`
- `specs/environment/foundation/BOOTSTRAP_FILES_REFERENCE.md`
- `specs/environment/foundation/BOOTSTRAP_ONBOARDING.md`

Runtime:
- `specs/runtime/nex/NEX.md`
- `specs/runtime/nex/NEXUS_REQUEST.md`
- `specs/runtime/nex/CONTROL_PLANE.md`

Broker:
- `specs/runtime/broker/OVERVIEW.md`
- `specs/runtime/broker/CONTEXT_ASSEMBLY.md`
- `specs/runtime/broker/QUEUE_MANAGEMENT.md`
- `specs/runtime/broker/SESSION_LIFECYCLE.md`
- `specs/runtime/broker/MEESEEKS_PATTERN.md`

Adapters:
- `specs/runtime/adapters/ADAPTER_SYSTEM.md`

Credentials:
- `specs/environment/capabilities/credentials/CREDENTIAL_SYSTEM.md`

Ledgers:
- `specs/data/ledgers/EVENTS_LEDGER.md`
- `specs/data/ledgers/AGENTS_LEDGER.md`
- `specs/data/ledgers/NEXUS_LEDGER.md`

Memory:
- `specs/data/cortex/MEMORY_SYSTEM.md`
