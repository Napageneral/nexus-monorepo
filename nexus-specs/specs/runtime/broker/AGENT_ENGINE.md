# Agent Engine Interface

**Status:** DESIGN SPEC  
**Last Updated:** 2026-02-05

---

## Overview

The Agent Engine is the Broker's wrapper around `pi-coding-agent`. It takes an `AssembledContext` from Context Assembly and produces an `AgentResult` that feeds into Ledger Writes and Streaming.

**The Broker does NOT reinvent agent execution.** It wraps `@mariozechner/pi-coding-agent`, replacing the storage layer (SQLite instead of JSONL) and adding Nexus-specific context.

```
Context Assembly → AssembledContext → Agent Engine → AgentResult → Ledger Writes
                                         ↓                           + Streaming
                                    pi-coding-agent
                                    (core agent loop)
```

---

## Input: AssembledContext

What the Broker hands to the Agent Engine after Context Assembly completes.

```typescript
interface AssembledContext {
  // === The Three Context Layers ===
  
  systemPrompt: string;              // Layer 1: static system prompt
  history: Message[];                // Layer 2: conversation history from ledger
  currentMessage: Message;           // Layer 3: event context + user message
  
  // === Tool Configuration ===
  
  tools: AgentTool[];                // Available tools (IAM-filtered)
  
  // === Model Configuration ===
  
  model: string;                     // e.g., 'claude-sonnet-4-20250514'
  provider: string;                  // e.g., 'anthropic'
  thinkingConfig?: ThinkingConfig;   // Extended thinking settings
  maxResponseTokens?: number;        // Max output tokens
  temperature?: number;              // Sampling temperature
  
  // === Token Budget ===
  
  tokenBudget: TokenBudget;          // Budget with current usage calculated
  
  // === Execution Controls ===
  
  timeoutMs: number;                 // Max execution time
  abortSignal?: AbortSignal;         // For cancellation
  runId: string;                     // Unique run identifier
  
  // === Metadata (for ledger writes, NOT sent to model) ===
  
  sessionLabel: string;              // Which session this turn belongs to
  parentTurnId: string;              // Parent turn in the tree
  role: AgentRole;                   // 'manager' | 'worker' | 'unified'
  toolsetName: string;               // Named toolset applied
  permissionsGranted: Permission[];  // IAM permissions snapshot
  sourceEventId?: string;            // NEX event that triggered this
  workspacePath: string;             // Workspace root
}
```

### Mapping from Upstream

The upstream `RunEmbeddedPiAgentParams` is a flat bag of ~30 params mixing concerns (session ID, channel info, sender context, workspace, model, streaming callbacks). We split these cleanly:

| Upstream param | Nexus equivalent | Where it lives |
|---------------|-----------------|----------------|
| `sessionId`, `sessionKey`, `sessionFile` | `sessionLabel`, `parentTurnId` | AssembledContext metadata |
| `messageChannel`, `messageProvider` | Event context in `currentMessage` | Layer 3 |
| `prompt`, `images` | `currentMessage.content` | Layer 3 |
| `workspaceDir`, `agentDir` | `workspacePath`, system prompt | Layer 1 + metadata |
| `provider`, `model` | `model`, `provider` | AssembledContext |
| `thinkLevel`, `reasoningLevel` | `thinkingConfig` | AssembledContext |
| `config` | Resolved by Broker before assembly | Not passed through |
| `skillsSnapshot` | Nexus CLI injection in system prompt | Layer 1 |
| `onPartialReply`, etc. | Streaming callbacks | Separate concern (see Streaming) |
| `groupId`, `senderId`, etc. | Event metadata in `currentMessage` | Layer 3 |

**Key simplification:** The agent engine gets a clean context. All the Nexus-specific routing, IAM resolution, and context assembly happens BEFORE this interface.

---

## Output: AgentResult

What the Agent Engine returns after execution completes.

```typescript
interface AgentResult {
  // === Messages produced ===
  
  messages: AgentMessage[];          // All messages in order (query echo, assistant, tool results)
  
  // === Tool calls ===
  
  toolCalls: AgentToolCall[];        // All tool invocations with results
  
  // === Token usage ===
  
  usage: TokenUsage;
  
  // === Execution metadata ===
  
  stopReason: StopReason;            // Why the agent stopped
  durationMs: number;                // Total execution time
  
  // === Error info ===
  
  error?: AgentError;                // If the turn failed
  
  // === Compaction (if triggered during execution) ===
  
  compaction?: CompactionResult;     // If context overflow triggered compaction
}
```

### AgentMessage

```typescript
interface AgentMessage {
  id: string;                        // Message ID (generated by agent engine)
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  sequence: number;                  // Order within turn
  createdAt: number;                 // Unix ms
  
  // Assistant-specific
  thinking?: string;                 // Extended thinking content
  
  // Tool-specific
  toolCallId?: string;               // Links tool result to tool call
}
```

### AgentToolCall

```typescript
interface AgentToolCall {
  id: string;                        // Tool call ID (from LLM)
  toolName: string;
  params: Record<string, unknown>;   // Parsed parameters
  
  result?: unknown;                  // Result value
  error?: string;                    // Error if failed
  
  status: 'pending' | 'running' | 'completed' | 'failed';
  
  startedAt: number;                 // Unix ms
  completedAt?: number;
  sequence: number;                  // Order within turn
  
  // If this tool call spawned a subagent
  spawnedSessionLabel?: string;
}
```

### TokenUsage

```typescript
interface TokenUsage {
  inputTokens: number;
  outputTokens: number;
  cachedInputTokens: number;         // Prompt cache reads
  cacheWriteTokens: number;          // Prompt cache writes
  reasoningTokens: number;           // Extended thinking
  totalTokens: number;
}
```

### StopReason

```typescript
type StopReason =
  | 'end_turn'           // Agent finished normally
  | 'max_tokens'         // Hit output token limit
  | 'tool_use'           // Agent wants to call a tool (shouldn't be final)
  | 'timeout'            // Execution timeout
  | 'aborted'            // Cancelled via AbortSignal
  | 'error';             // Failed (see error field)
```

### AgentError

```typescript
interface AgentError {
  kind: 'context_overflow'           // Context too large even after compaction
      | 'auth_failure'               // All auth profiles exhausted
      | 'rate_limit'                 // Rate limited, no fallback available
      | 'model_error'                // Model returned an error
      | 'timeout'                    // Execution exceeded timeoutMs
      | 'compaction_failure'         // Compaction itself failed
      | 'unknown';
  message: string;
  retryable: boolean;                // Can the Broker retry this?
}
```

### CompactionResult

```typescript
interface CompactionResult {
  summary: string;
  summarizedThroughTurnId: string;
  firstKeptTurnId: string;
  turnsSummarized: number;
  
  model: string;                     // Summarization model used
  provider: string;
  
  tokensBefore: number;
  tokensAfter: number;
  summaryTokens: number;
  summarizationInputTokens: number;
  summarizationOutputTokens: number;
  durationMs: number;
  
  trigger: 'context_limit' | 'overflow_recovery';
}
```

---

## AgentResult → Ledger Writes

The Broker maps `AgentResult` to Agents Ledger tables:

```
AgentResult
  │
  ├─→ turns table
  │     id: generated ULID
  │     parent_turn_id: from AssembledContext.parentTurnId
  │     turn_type: 'normal' (or 'compaction' if compaction turn)
  │     status: derived from stopReason/error
  │     model, provider: from AssembledContext
  │     role: from AssembledContext
  │     toolset_name, tools_available, permissions_*: from AssembledContext
  │     input_tokens, output_tokens, ...: from AgentResult.usage
  │     query_message_ids: IDs of input messages
  │     response_message_id: ID of final assistant message
  │     source_event_id, workspace_path: from AssembledContext
  │
  ├─→ messages table
  │     One row per AgentMessage
  │     turn_id: the new turn's ID
  │     context_json: on system/user messages, captures assembly metadata
  │
  ├─→ tool_calls table
  │     One row per AgentToolCall
  │     turn_id: the new turn's ID
  │     message_id: the assistant message that triggered the call
  │
  ├─→ compactions table (if compaction triggered)
  │     turn_id: compaction turn ID
  │     All fields from CompactionResult
  │
  ├─→ threads table
  │     turn_id: the new turn's ID
  │     ancestry: parent thread ancestry + this turn
  │     total_tokens: parent total + this turn's tokens
  │
  ├─→ sessions table
  │     UPDATE thread_id to point to new thread head
  │     UPDATE updated_at
  │
  └─→ session_history table
        Log the pointer movement
```

### Write Sequence

```typescript
async function writeTurnToLedger(
  ctx: AssembledContext,
  result: AgentResult
): Promise<string> {
  const turnId = generateULID();
  
  // All writes in a single transaction
  await db.transaction(async (tx) => {
    // 1. Insert turn
    await tx.run(`
      INSERT INTO turns (id, parent_turn_id, turn_type, status, 
        started_at, completed_at, model, provider, role,
        toolset_name, tools_available, permissions_granted, permissions_used,
        input_tokens, output_tokens, cached_input_tokens, cache_write_tokens,
        reasoning_tokens, total_tokens, query_message_ids, response_message_id,
        has_children, tool_call_count, source_event_id, workspace_path)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [turnId, ctx.parentTurnId, 'normal', mapStopToStatus(result), ...]);
    
    // 2. Insert messages
    for (const msg of result.messages) {
      await tx.run(`INSERT INTO messages (...) VALUES (...)`, [...]);
    }
    
    // 3. Insert tool calls
    for (const tc of result.toolCalls) {
      await tx.run(`INSERT INTO tool_calls (...) VALUES (...)`, [...]);
    }
    
    // 4. Update parent turn
    await tx.run(`UPDATE turns SET has_children = 1 WHERE id = ?`, [ctx.parentTurnId]);
    
    // 5. Insert/update thread
    const parentThread = await tx.get(`SELECT * FROM threads WHERE turn_id = ?`, [ctx.parentTurnId]);
    const ancestry = [...JSON.parse(parentThread.ancestry), turnId];
    await tx.run(`INSERT INTO threads (...) VALUES (...)`, [turnId, JSON.stringify(ancestry), ...]);
    
    // 6. Update session pointer
    await tx.run(`UPDATE sessions SET thread_id = ?, updated_at = ? WHERE label = ?`,
      [turnId, Date.now(), ctx.sessionLabel]);
    
    // 7. Log session history
    await tx.run(`INSERT INTO session_history (session_label, thread_id, changed_at) VALUES (?, ?, ?)`,
      [ctx.sessionLabel, turnId, Date.now()]);
    
    // 8. If compaction happened, write compaction record
    if (result.compaction) {
      await tx.run(`INSERT INTO compactions (...) VALUES (...)`, [...]);
    }
  });
  
  return turnId;
}
```

---

## Streaming Interface

The Agent Engine produces streaming callbacks during execution. The Broker translates these into `StreamEvent` objects and emits them to NEX. The Broker always streams raw events — it never coalesces or buffers. Platform-specific rendering is handled downstream by adapters (or NEX's block pipeline fallback).

### Agent Engine Callbacks

These are the raw callbacks from `pi-coding-agent`:

```typescript
interface AgentEngineCallbacks {
  // Raw token output
  onPartialReply: (payload: { text: string; messageId?: string }) => void;
  
  // Extended thinking output
  onReasoningStream: (payload: { text: string }) => void;
  
  // Tool execution events
  onToolResult: (payload: { toolCallId: string; toolName: string; status: 'started' | 'completed' | 'failed'; summary?: string }) => void;
  
  // Lifecycle events
  onAgentEvent: (event: { phase: 'start' | 'streaming' | 'tool_use' | 'compaction_start' | 'compaction_end' | 'end'; timestamp: number }) => void;
}
```

### Broker Translation

The Broker translates agent callbacks into `StreamEvent` objects:

```typescript
// Broker emits these to NEX
type StreamEvent =
  | { type: 'stream_start'; runId: string; sessionLabel: string; target: DeliveryTarget }
  | { type: 'token'; text: string }
  | { type: 'tool_status'; toolName: string; toolCallId: string; status: 'started' | 'completed' | 'failed'; summary?: string }
  | { type: 'reasoning'; text: string }
  | { type: 'stream_end'; runId: string; final?: boolean }
  | { type: 'stream_error'; error: string; partial: boolean };
```

### Broker → NEX Handle

```typescript
interface BrokerStreamHandle {
  onEvent(callback: (event: StreamEvent) => void): void;
  abort(): void;
  steer(message: string): boolean;
  isStreaming(): boolean;
  isCompacting(): boolean;
}

interface BrokerExecution {
  stream: BrokerStreamHandle;       // Real-time streaming (during execution)
  result: Promise<AgentResult>;     // Final result (after execution)
}
```

### Streaming Flow

```
Agent Engine                     Broker                         NEX                        Adapter
    │                              │                              │                           │
    ├── onAgentEvent(start) ──────→│── stream_start ─────────────→│── route to adapter ──────→│
    ├── onPartialReply(token) ────→│── token ────────────────────→│── pipe or coalesce ──────→│
    ├── onPartialReply(token) ────→│── token ────────────────────→│── pipe or coalesce ──────→│
    ├── onToolResult(started) ────→│── tool_status ──────────────→│── pipe or render ────────→│
    ├── onToolResult(completed) ──→│── tool_status ──────────────→│── pipe or render ────────→│
    ├── onPartialReply(token) ────→│── token ────────────────────→│── pipe or coalesce ──────→│
    ├── onAgentEvent(end) ────────→│── stream_end ───────────────→│── finalize ─────────────→│
    │                              │                              │                           │
    └── return AgentResult ───────→│── writeTurnToLedger()        │                           │
```

**Streaming and persistence are separate.** Streaming happens DURING execution via callbacks → StreamEvents. Ledger writes happen AFTER execution from the final `AgentResult`. NEX routes StreamEvents to the adapter (if it supports `stream`) or coalesces into blocks (fallback for adapters with `send` only).

See `STREAMING.md` for the full streaming architecture.

---

## Execution Flow

### Normal Turn

```
1. Broker receives NexusRequest from NEX
2. Context Assembly produces AssembledContext
3. Check token budget → compact if needed (proactive)
4. Agent Engine executes:
   a. Send system prompt + history + current message to LLM
   b. Stream response tokens via callbacks
   c. Execute tool calls as they come in
   d. Collect final result
5. If context overflow error → compact → retry once (reactive fallback)
6. Write AgentResult to Agents Ledger
7. Deliver response via NEX
8. Drain message queue if pending messages exist
```

### Compaction During Execution

```
1. Agent Engine detects context overflow from LLM
2. Triggers compaction:
   a. Select turns to summarize vs keep
   b. Call summarization model
   c. Build CompactionResult
3. Rebuild context with summary + kept turns
4. Retry the original turn with compacted context
5. CompactionResult included in AgentResult for ledger write
```

### Subagent Spawning

```
1. During execution, agent calls a spawn tool (e.g., Task)
2. Tool handler:
   a. Creates new session (is_subagent = 1, parent linking)
   b. Runs Context Assembly for worker context
   c. Executes worker via Agent Engine (recursive)
   d. Returns worker result to parent tool call
3. Parent AgentResult includes the tool call with spawned_session_label
```

---

## Failover Strategy

### Auth Profile Rotation

When an LLM request fails due to auth/rate-limit:

1. Mark current profile in cooldown
2. Select next available profile (from IAM/credential store)
3. Retry with new profile
4. If all profiles exhausted → error with `auth_failure`

### Model Fallback

If configured, the Broker can fall back to alternate models:

```typescript
// Example fallback chain
const fallbackChain = ['claude-sonnet-4', 'gpt-4o', 'claude-haiku-4'];
```

Fallback happens when:
- Primary model is rate limited and no auth profiles available
- Primary model returns persistent errors

**Note:** Model fallback changes the context window and token budget. The Broker must recalculate the budget for the fallback model.

---

## What pi-coding-agent Handles (We Don't Reinvent)

- Core agent loop (message → LLM → tool calls → response)
- Tool execution framework and sandboxing
- LLM API communication (Anthropic, OpenAI, etc.)
- Response parsing and content block handling
- Thinking/reasoning mode management

## What the Broker Adds

- Context Assembly (three layers, Nexus-specific context)
- SQLite persistence (Agents Ledger instead of JSONL)
- IAM-based tool filtering (instead of config-based policies)
- Nexus environment injection (capabilities, skills discovery)
- Streaming bridge to NEX pipeline
- Session pointer management
- Subagent orchestration

---

## Open Questions

1. **Exact pi-coding-agent API surface:** Need to trace the actual function signatures in `@mariozechner/pi-coding-agent`. The upstream reference shows the OpenClaw wrapper — we need the underlying library interface.
2. **Session file compatibility:** pi-coding-agent expects a session file (JSONL). Do we provide a compatibility shim that reads from SQLite, or do we fork the session management?
3. **Tool creation interface:** How do we inject our IAM-filtered toolset into pi-coding-agent's tool framework?
4. **Streaming callback registration:** How exactly do we hook into pi-coding-agent's streaming? Direct callback params or event emitter?

---

## Related Documents

- `CONTEXT_ASSEMBLY.md` — How AssembledContext is built
- `OVERVIEW.md` — Broker overview and architecture
- `STREAMING.md` — Streaming bridge spec (TODO)
- `../../data/ledgers/AGENTS_LEDGER.md` — Schema for persistence
- `upstream/AGENT_EXECUTION.md` — OpenClaw execution reference

---

*This document defines the Agent Engine interface — the boundary between Context Assembly and execution. It dictates ledger writes, streaming, and the shape of agent results.*
