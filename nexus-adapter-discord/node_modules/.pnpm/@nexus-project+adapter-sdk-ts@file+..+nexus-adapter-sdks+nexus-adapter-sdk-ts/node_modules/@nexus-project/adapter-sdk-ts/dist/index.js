import fs from "node:fs";
import { z } from "zod";
import util from "node:util";
import readline from "node:readline";

//#region src/runtime-context.ts
const ADAPTER_CONTEXT_ENV_VAR = "NEXUS_ADAPTER_CONTEXT_PATH";
const AdapterRuntimeCredentialSchemaV1 = z.object({
	ref: z.string(),
	service: z.string(),
	account: z.string(),
	value: z.string()
});
const AdapterRuntimeCredentialSchemaV2 = z.object({
	kind: z.string(),
	value: z.string()
}).catchall(z.unknown());
const AdapterRuntimeContextFileSchema = z.object({
	version: z.number().optional(),
	channel: z.string(),
	account_id: z.string(),
	config: z.record(z.string(), z.unknown()).default({}),
	credential: z.union([AdapterRuntimeCredentialSchemaV2, AdapterRuntimeCredentialSchemaV1]).optional()
}).catchall(z.unknown());
function normalizeCredential(cred) {
	if (!cred) return;
	const v2 = AdapterRuntimeCredentialSchemaV2.safeParse(cred);
	if (v2.success) {
		const rec = v2.data;
		const ref = typeof rec.ref === "string" ? rec.ref : void 0;
		const service = typeof rec.service === "string" ? rec.service : void 0;
		const account = typeof rec.account === "string" ? rec.account : void 0;
		return {
			kind: rec.kind,
			value: rec.value,
			...ref ? { ref } : {},
			...service ? { service } : {},
			...account ? { account } : {}
		};
	}
	const v1 = AdapterRuntimeCredentialSchemaV1.safeParse(cred);
	if (v1.success) return {
		kind: "token",
		ref: v1.data.ref,
		service: v1.data.service,
		account: v1.data.account,
		value: v1.data.value
	};
	throw new Error("Invalid runtime context credential shape");
}
function readAdapterRuntimeContextFile(pathValue) {
	const raw = fs.readFileSync(pathValue, "utf8");
	const parsed = JSON.parse(raw);
	const file = AdapterRuntimeContextFileSchema.parse(parsed);
	return {
		channel: file.channel,
		account_id: file.account_id,
		config: file.config,
		...file.credential ? { credential: normalizeCredential(file.credential) } : {},
		raw: file
	};
}
function loadAdapterRuntimeContext(env = process.env) {
	const pathValue = env[ADAPTER_CONTEXT_ENV_VAR]?.trim();
	if (!pathValue) return null;
	return readAdapterRuntimeContextFile(pathValue);
}
function requireAdapterRuntimeContext(env = process.env) {
	const context = loadAdapterRuntimeContext(env);
	if (!context) throw new Error(`Missing adapter runtime context (expected $${ADAPTER_CONTEXT_ENV_VAR} to point at runtime-context.json)`);
	return context;
}

//#endregion
//#region src/logger.ts
function createAdapterLogger(opts) {
	const stderr = opts.stderr ?? process.stderr;
	const verbose = opts.verbose;
	const write = (prefix, message, ...args) => {
		const rendered = args.length > 0 ? util.format(message, ...args) : message;
		stderr.write(`${prefix}${rendered}\n`);
	};
	return {
		error: (message, ...args) => write("[ERROR] ", message, ...args),
		info: (message, ...args) => write("[INFO] ", message, ...args),
		debug: (message, ...args) => {
			if (!verbose) return;
			write("[DEBUG] ", message, ...args);
		}
	};
}
function patchConsoleToStderr(log) {
	console.log = (...args) => log.info("%s", util.format(...args));
	console.info = (...args) => log.info("%s", util.format(...args));
	console.warn = (...args) => log.info("%s", util.format(...args));
	console.error = (...args) => log.error("%s", util.format(...args));
}

//#endregion
//#region src/io.ts
function writeJSONLine(stdout, payload) {
	stdout.write(`${JSON.stringify(payload)}\n`);
}
async function* readJSONLines(stream) {
	const rl = readline.createInterface({
		input: stream,
		crlfDelay: Number.POSITIVE_INFINITY
	});
	for await (const line of rl) {
		const trimmed = String(line).trim();
		if (!trimmed) continue;
		yield JSON.parse(trimmed);
	}
}

//#endregion
//#region src/protocol.ts
const AdapterCapabilitySchema = z.enum([
	"monitor",
	"send",
	"stream",
	"backfill",
	"health",
	"accounts",
	"react",
	"edit",
	"delete",
	"poll"
]);
const ChannelCapabilitiesSchema = z.object({
	text_limit: z.number().int().nonnegative(),
	caption_limit: z.number().int().nonnegative().optional(),
	supports_markdown: z.boolean(),
	markdown_flavor: z.string().optional(),
	supports_tables: z.boolean(),
	supports_code_blocks: z.boolean(),
	supports_embeds: z.boolean(),
	supports_threads: z.boolean(),
	supports_reactions: z.boolean(),
	supports_polls: z.boolean(),
	supports_buttons: z.boolean(),
	supports_edit: z.boolean(),
	supports_delete: z.boolean(),
	supports_media: z.boolean(),
	supports_voice_notes: z.boolean(),
	supports_streaming_edit: z.boolean()
}).catchall(z.unknown());
const AdapterInfoSchema = z.object({
	channel: z.string(),
	name: z.string(),
	version: z.string(),
	supports: z.array(AdapterCapabilitySchema),
	credential_service: z.string().optional(),
	multi_account: z.boolean(),
	channel_capabilities: ChannelCapabilitiesSchema
});
const AttachmentSchema = z.object({
	id: z.string(),
	filename: z.string(),
	content_type: z.string(),
	size_bytes: z.number().int().nonnegative().optional(),
	url: z.string().optional(),
	path: z.string().optional()
});
const ContainerKindSchema = z.enum([
	"dm",
	"direct",
	"group",
	"channel"
]);
const PeerKindSchema = ContainerKindSchema;
const ContentTypeSchema = z.enum([
	"text",
	"image",
	"audio",
	"video",
	"file",
	"reaction",
	"membership"
]);
const NexusEventSchema = z.object({
	event_id: z.string(),
	timestamp: z.number().int(),
	content: z.string(),
	content_type: ContentTypeSchema,
	attachments: z.array(AttachmentSchema).optional(),
	platform: z.string(),
	account_id: z.string(),
	sender_id: z.string(),
	sender_name: z.string().optional(),
	space_id: z.string().optional(),
	space_name: z.string().optional(),
	container_id: z.string(),
	container_kind: ContainerKindSchema,
	container_name: z.string().optional(),
	thread_id: z.string().optional(),
	thread_name: z.string().optional(),
	reply_to_id: z.string().optional(),
	metadata: z.record(z.string(), z.unknown()).optional(),
	delivery_metadata: z.record(z.string(), z.unknown()).optional()
});
const DeliveryErrorTypeSchema = z.enum([
	"rate_limited",
	"permission_denied",
	"not_found",
	"content_rejected",
	"network",
	"unknown"
]);
const DeliveryErrorSchema = z.object({
	type: DeliveryErrorTypeSchema,
	message: z.string(),
	retry: z.boolean(),
	retry_after_ms: z.number().int().nonnegative().optional(),
	details: z.record(z.string(), z.unknown()).optional()
});
const DeliveryResultSchema = z.object({
	success: z.boolean(),
	message_ids: z.array(z.string()),
	chunks_sent: z.number().int().nonnegative(),
	total_chars: z.number().int().nonnegative().optional(),
	error: DeliveryErrorSchema.optional()
});
const SendRequestSchema = z.object({
	account: z.string(),
	to: z.string(),
	text: z.string().optional(),
	media: z.string().optional(),
	caption: z.string().optional(),
	reply_to_id: z.string().optional(),
	thread_id: z.string().optional()
});
const AdapterHealthSchema = z.object({
	connected: z.boolean(),
	account: z.string(),
	last_event_at: z.number().int().optional(),
	error: z.string().optional(),
	details: z.record(z.string(), z.unknown()).optional()
});
const AdapterAccountSchema = z.object({
	id: z.string(),
	display_name: z.string().optional(),
	credential_ref: z.string().optional(),
	status: z.enum([
		"ready",
		"active",
		"error"
	])
});
const DeliveryTargetSchema = z.object({
	platform: z.string(),
	account_id: z.string(),
	to: z.string(),
	thread_id: z.string().optional(),
	reply_to_id: z.string().optional()
});
const StreamEventSchema = z.discriminatedUnion("type", [
	z.object({
		type: z.literal("stream_start"),
		runId: z.string(),
		sessionLabel: z.string(),
		target: DeliveryTargetSchema
	}),
	z.object({
		type: z.literal("token"),
		text: z.string()
	}),
	z.object({
		type: z.literal("tool_status"),
		toolName: z.string(),
		toolCallId: z.string(),
		status: z.enum([
			"started",
			"completed",
			"failed"
		]),
		summary: z.string().optional()
	}),
	z.object({
		type: z.literal("reasoning"),
		text: z.string()
	}),
	z.object({
		type: z.literal("stream_end"),
		runId: z.string(),
		final: z.boolean().optional()
	}),
	z.object({
		type: z.literal("stream_error"),
		error: z.string(),
		partial: z.boolean()
	})
]);
const AdapterStreamStatusSchema = z.discriminatedUnion("type", [
	z.object({
		type: z.literal("message_created"),
		messageId: z.string()
	}),
	z.object({
		type: z.literal("message_updated"),
		messageId: z.string(),
		chars: z.number().int().nonnegative()
	}),
	z.object({
		type: z.literal("message_sent"),
		messageId: z.string(),
		final: z.boolean()
	}),
	z.object({
		type: z.literal("delivery_complete"),
		messageIds: z.array(z.string())
	}),
	z.object({
		type: z.literal("delivery_error"),
		error: z.string()
	})
]);

//#endregion
//#region src/stream.ts
function emitStreamStatus(status, stdout = process.stdout, validate = true) {
	writeJSONLine(stdout, validate ? AdapterStreamStatusSchema.parse(status) : status);
}
async function handleStream(opts) {
	const stdin = opts.stdin ?? process.stdin;
	const stdout = opts.stdout ?? process.stdout;
	const validate = opts.validate ?? true;
	const ctx = opts.ctx;
	const handlers = opts.handlers;
	const dispatchError = async (log, message) => {
		log.error("%s", message);
		emitStreamStatus({
			type: "delivery_error",
			error: message
		}, stdout, validate);
	};
	for await (const raw of readJSONLines(stdin)) {
		if (ctx.signal.aborted) {
			ctx.log.info("stream shutting down (signal aborted)");
			return;
		}
		let event;
		try {
			event = validate ? StreamEventSchema.parse(raw) : raw;
		} catch (err) {
			await dispatchError(ctx.log, `stream: failed to parse event: ${errorToString$2(err)}`);
			continue;
		}
		try {
			switch (event.type) {
				case "stream_start":
					if (handlers.onStart) await handlers.onStart(ctx, event);
					break;
				case "token":
					if (handlers.onToken) await handlers.onToken(ctx, event);
					break;
				case "tool_status":
					if (handlers.onToolStatus) await handlers.onToolStatus(ctx, event);
					break;
				case "reasoning":
					if (handlers.onReasoning) await handlers.onReasoning(ctx, event);
					break;
				case "stream_end":
					if (handlers.onEnd) await handlers.onEnd(ctx, event);
					break;
				case "stream_error":
					if (handlers.onError) await handlers.onError(ctx, event);
					break;
				default: ctx.log.debug("stream: unknown event type: %s", event.type);
			}
		} catch (err) {
			await dispatchError(ctx.log, `stream handler error for ${event.type}: ${errorToString$2(err)}`);
		}
	}
}
function errorToString$2(err) {
	return err instanceof Error ? err.message : String(err);
}

//#endregion
//#region src/run.ts
async function runAdapter(adapter, opts = {}) {
	const argv = opts.argv ?? process.argv;
	const env = opts.env ?? process.env;
	const stdin = opts.stdin ?? process.stdin;
	const stdout = opts.stdout ?? process.stdout;
	const stderr = opts.stderr ?? process.stderr;
	const requireRuntimeContext = opts.requireRuntimeContext ?? true;
	const validateOutput = opts.validateOutput ?? true;
	const doPatchConsole = opts.patchConsole ?? true;
	const installSignalHandlers = opts.installSignalHandlers ?? true;
	const command = String(argv[2] ?? "").trim();
	const args = argv.slice(3);
	const log = createAdapterLogger({
		verbose: args.includes("--verbose") || args.includes("-v"),
		stderr
	});
	if (doPatchConsole) patchConsoleToStderr(log);
	if (!command || command === "help" || command === "--help" || command === "-h") {
		printUsage(argv[1] ?? "adapter", stderr);
		return command ? 0 : 1;
	}
	const filteredArgs = args.filter((a) => a !== "--verbose" && a !== "-v");
	const controller = new AbortController();
	if (installSignalHandlers) {
		const onSignal = () => controller.abort();
		process.on("SIGINT", onSignal);
		process.on("SIGTERM", onSignal);
	}
	let runtime = null;
	if (command !== "info") try {
		runtime = requireRuntimeContext ? requireAdapterRuntimeContext(env) : loadAdapterRuntimeContext(env);
	} catch (err) {
		log.error("%s", errorToString$1(err));
		return 1;
	}
	const ctx = {
		signal: controller.signal,
		runtime,
		log,
		stdout,
		stderr
	};
	try {
		switch (command) {
			case "info": {
				const info = await adapter.info();
				writeJSONLine(stdout, validateOutput ? AdapterInfoSchema.parse(info) : info);
				return 0;
			}
			case "monitor": {
				if (!adapter.monitor) throw new Error("monitor not supported by this adapter");
				const account = requireFlag(filteredArgs, "--account");
				const emit = (event) => {
					writeJSONLine(stdout, validateOutput ? NexusEventSchema.parse(event) : event);
				};
				ctx.log.info("monitor starting for account %s", JSON.stringify(account));
				await adapter.monitor(ctx, { account }, emit);
				ctx.log.info("monitor stopped cleanly");
				return 0;
			}
			case "backfill": {
				if (!adapter.backfill) throw new Error("backfill not supported by this adapter");
				const account = requireFlag(filteredArgs, "--account");
				const since = parseDate(requireFlag(filteredArgs, "--since"));
				const emit = (event) => {
					writeJSONLine(stdout, validateOutput ? NexusEventSchema.parse(event) : event);
				};
				ctx.log.info("backfill starting for account %s since %s", JSON.stringify(account), since.toISOString());
				await adapter.backfill(ctx, {
					account,
					since
				}, emit);
				ctx.log.info("backfill completed");
				return 0;
			}
			case "send": {
				if (!adapter.send) throw new Error("send not supported by this adapter");
				const account = requireFlag(filteredArgs, "--account");
				const to = requireFlag(filteredArgs, "--to");
				const text = readFlag(filteredArgs, "--text");
				const media = readFlag(filteredArgs, "--media");
				const caption = readFlag(filteredArgs, "--caption");
				const replyTo = readFlag(filteredArgs, "--reply-to");
				const threadID = readFlag(filteredArgs, "--thread");
				if (!text && !media) throw new Error("send requires --text or --media");
				if (text && media) throw new Error("send must not specify both --text and --media");
				if (caption && !media) throw new Error("send --caption requires --media");
				const req = {
					account,
					to,
					...text ? { text } : {},
					...media ? { media } : {},
					...caption ? { caption } : {},
					...replyTo ? { reply_to_id: replyTo } : {},
					...threadID ? { thread_id: threadID } : {}
				};
				const parsedReq = validateOutput ? SendRequestSchema.parse(req) : req;
				try {
					const result = await adapter.send(ctx, parsedReq);
					writeJSONLine(stdout, validateOutput ? DeliveryResultSchema.parse(result) : result);
					return 0;
				} catch (err) {
					const failure = {
						success: false,
						message_ids: [],
						chunks_sent: 0,
						error: {
							type: "unknown",
							message: errorToString$1(err),
							retry: false
						}
					};
					writeJSONLine(stdout, validateOutput ? DeliveryResultSchema.parse(failure) : failure);
					return 0;
				}
			}
			case "health": {
				if (!adapter.health) throw new Error("health not supported by this adapter");
				const account = requireFlag(filteredArgs, "--account");
				try {
					const health = await adapter.health(ctx, { account });
					writeJSONLine(stdout, validateOutput ? AdapterHealthSchema.parse(health) : health);
					return 0;
				} catch (err) {
					const health = {
						connected: false,
						account,
						error: errorToString$1(err)
					};
					writeJSONLine(stdout, validateOutput ? AdapterHealthSchema.parse(health) : health);
					return 0;
				}
			}
			case "accounts": {
				if (!adapter.accounts) throw new Error("accounts not supported by this adapter");
				const subcmd = readSubcommand(filteredArgs) ?? "list";
				switch (subcmd) {
					case "list": {
						const accounts = await adapter.accounts(ctx);
						writeJSONLine(stdout, validateOutput ? zArray(AdapterAccountSchema).parse(accounts) : accounts);
						return 0;
					}
					default: throw new Error(`unknown accounts subcommand: ${subcmd} (expected: list)`);
				}
			}
			case "stream":
				if (!adapter.stream) throw new Error("stream not supported by this adapter");
				requireFlag(filteredArgs, "--account");
				ctx.log.info("stream handler starting");
				await handleStream({
					ctx,
					handlers: adapter.stream,
					stdin,
					stdout,
					validate: validateOutput
				});
				ctx.log.info("stream handler stopped cleanly");
				return 0;
			default:
				stderr.write(`unknown command: ${command}\n`);
				printUsage(argv[1] ?? "adapter", stderr);
				return 1;
		}
	} catch (err) {
		log.error("%s", errorToString$1(err));
		return 1;
	}
}
function printUsage(name, stderr) {
	stderr.write(`Usage: ${name} <command> [flags]\n\n`);
	stderr.write("Commands:\n");
	stderr.write("  info                              Self-describe this adapter\n");
	stderr.write("  monitor  --account <id>           Stream live events (JSONL)\n");
	stderr.write("  send     --account <id> --to <target> --text \"...\"\n");
	stderr.write("  backfill --account <id> --since <date>\n");
	stderr.write("  health   --account <id>           Check connection status\n");
	stderr.write("  accounts list                     List configured accounts\n");
	stderr.write("  stream   --account <id>           Streaming delivery (stdin/stdout)\n\n");
	stderr.write("Global flags:\n");
	stderr.write("  --verbose, -v                     Enable debug logging\n");
}
function readFlag(args, name) {
	const eqPrefix = `${name}=`;
	for (let i = 0; i < args.length; i++) {
		const a = args[i];
		if (a === name) {
			const v = args[i + 1];
			return typeof v === "string" ? v : void 0;
		}
		if (a.startsWith(eqPrefix)) return a.slice(eqPrefix.length);
	}
}
function requireFlag(args, name) {
	const v = readFlag(args, name);
	if (!v || !v.trim()) throw new Error(`Missing required flag: ${name}`);
	return v;
}
function readSubcommand(args) {
	for (const a of args) {
		if (!a) continue;
		if (a.startsWith("-")) continue;
		return a;
	}
}
function parseDate(s) {
	const trimmed = s.trim();
	if (!trimmed) throw new Error("date is required");
	const parsed = Date.parse(trimmed);
	if (!Number.isNaN(parsed)) return new Date(parsed);
	const m = /^(\d{4})-(\d{2})-(\d{2})$/u.exec(trimmed);
	if (m) return /* @__PURE__ */ new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00Z`);
	throw new Error("unrecognized date format (expected ISO 8601 or YYYY-MM-DD)");
}
function errorToString$1(err) {
	return err instanceof Error ? err.message : String(err);
}
function zArray(schema) {
	return { parse: (value) => {
		if (!Array.isArray(value)) throw new Error("expected array");
		return value.map((v) => schema.parse(v));
	} };
}

//#endregion
//#region src/monitor.ts
function pollMonitor(config) {
	return async (ctx, args, emit) => {
		const intervalMs = config.intervalMs;
		if (!Number.isFinite(intervalMs) || intervalMs <= 0) throw new Error(`pollMonitor: invalid intervalMs: ${intervalMs}`);
		let cursor = config.initialCursor ?? /* @__PURE__ */ new Date();
		let errorBackoffMs = config.errorBackoffMs ?? intervalMs;
		if (!Number.isFinite(errorBackoffMs) || errorBackoffMs <= 0) errorBackoffMs = intervalMs;
		let consecutiveErrors = 0;
		const maxConsecutiveErrors = config.maxConsecutiveErrors ?? 0;
		while (true) {
			if (ctx.signal.aborted) {
				ctx.log.info("monitor shutting down (signal aborted)");
				return;
			}
			let fetched;
			try {
				fetched = await config.fetch(ctx, cursor, args.account);
			} catch (err) {
				consecutiveErrors++;
				ctx.log.error("poll fetch error (%d consecutive): %s", consecutiveErrors, errorToString(err));
				if (maxConsecutiveErrors > 0 && consecutiveErrors >= maxConsecutiveErrors) throw err instanceof Error ? err : new Error(String(err));
				await sleep(errorBackoffMs, ctx.signal, ctx.log);
				continue;
			}
			consecutiveErrors = 0;
			const events = fetched.events ?? [];
			for (const event of events) emit(event);
			if (events.length > 0) ctx.log.debug("emitted %d events", events.length);
			if (fetched.newCursor instanceof Date && !Number.isNaN(fetched.newCursor.valueOf())) cursor = fetched.newCursor;
			await sleep(intervalMs, ctx.signal, ctx.log);
		}
	};
}
function errorToString(err) {
	return err instanceof Error ? err.message : String(err);
}
async function sleep(ms, signal, log) {
	await new Promise((resolve) => {
		const t = setTimeout(() => {
			signal.removeEventListener("abort", onAbort);
			resolve();
		}, ms);
		const onAbort = () => {
			clearTimeout(t);
			signal.removeEventListener("abort", onAbort);
			log.debug("sleep aborted");
			resolve();
		};
		if (signal.aborted) {
			clearTimeout(t);
			resolve();
			return;
		}
		signal.addEventListener("abort", onAbort, { once: true });
	});
}

//#endregion
//#region src/send.ts
function chunkText(text, limit) {
	if (!text) return [];
	if (limit <= 0 || text.length <= limit) return [text];
	const segments = [];
	const lines = text.split("\n");
	let outside = "";
	let inFence = false;
	let fenceChar = "";
	let fenceLen = 0;
	let openLine = "";
	let body = "";
	const flushOutside = () => {
		if (outside) {
			segments.push({
				kind: "text",
				content: outside
			});
			outside = "";
		}
	};
	const isFenceLine = (lineNoNL) => {
		const trimmed = lineNoNL.replace(/^[ \t]+/u, "");
		if (!trimmed.startsWith("```") && !trimmed.startsWith("~~~")) return null;
		const ch = trimmed[0];
		let n = 0;
		while (n < trimmed.length && trimmed[n] === ch) n++;
		if (n < 3) return null;
		return {
			ch,
			n
		};
	};
	const isFenceClose = (lineNoNL, ch, n) => {
		const trimmed = lineNoNL.replace(/^[ \t]+/u, "");
		if (!trimmed.startsWith(ch.repeat(Math.min(3, n)))) return false;
		let i = 0;
		while (i < trimmed.length && trimmed[i] === ch) i++;
		return i >= n;
	};
	for (let i = 0; i < lines.length; i++) {
		const lineNoNL = lines[i] ?? "";
		const fullLine = i < lines.length - 1 ? `${lineNoNL}\n` : lineNoNL;
		if (!inFence) {
			const fence = isFenceLine(lineNoNL);
			if (fence) {
				flushOutside();
				inFence = true;
				fenceChar = fence.ch;
				fenceLen = fence.n;
				openLine = fullLine;
				body = "";
				continue;
			}
			outside += fullLine;
			continue;
		}
		if (isFenceClose(lineNoNL, fenceChar, fenceLen)) {
			const closeLine = fullLine;
			segments.push({
				kind: "fence",
				open: openLine,
				body,
				close: closeLine
			});
			inFence = false;
			fenceChar = "";
			fenceLen = 0;
			openLine = "";
			body = "";
			continue;
		}
		body += fullLine;
	}
	if (inFence) {
		const closeLine = `${fenceChar.repeat(Math.max(3, fenceLen))}\n`;
		segments.push({
			kind: "fence",
			open: openLine,
			body,
			close: closeLine
		});
	} else flushOutside();
	const chunks = [];
	let current = "";
	const pushCurrent = () => {
		const out = current.replace(/[ ]+$/u, "");
		if (out) chunks.push(out);
		current = "";
	};
	const appendText = (segment) => {
		let remaining = segment;
		while (remaining.length > 0) {
			if (!current) {
				if (remaining.length <= limit) {
					current = remaining;
					return;
				}
				const splitAt = findSplitPoint(remaining, limit);
				const piece = remaining.slice(0, splitAt).replace(/[ ]+$/u, "");
				if (piece) {
					current = piece;
					pushCurrent();
				}
				remaining = remaining.slice(splitAt).replace(/^[ ]+/u, "");
				continue;
			}
			const available = limit - current.length;
			if (available <= 0) {
				pushCurrent();
				continue;
			}
			if (remaining.length <= available) {
				current += remaining;
				return;
			}
			const splitAt = findSplitPoint(remaining, available);
			const piece = remaining.slice(0, splitAt).replace(/[ ]+$/u, "");
			if (piece) {
				current += piece;
				pushCurrent();
			}
			remaining = remaining.slice(splitAt).replace(/^[ ]+/u, "");
		}
	};
	const splitFence = (open, bodyText, close) => {
		const full = `${open}${bodyText}${close}`;
		if (full.length <= limit) return [full];
		const maxBody = limit - (open.length + close.length);
		if (maxBody <= 0) return [full];
		const parts = [];
		const bodyLines = bodyText.split("\n");
		let buf = "";
		const flush = () => {
			if (!buf) return;
			parts.push(buf);
			buf = "";
		};
		for (let i = 0; i < bodyLines.length; i++) {
			const lineNoNL = bodyLines[i] ?? "";
			const line = i < bodyLines.length - 1 ? `${lineNoNL}\n` : lineNoNL;
			if (line.length > maxBody) {
				flush();
				let remaining = line;
				while (remaining.length > 0) {
					const take = Math.min(maxBody, remaining.length);
					parts.push(remaining.slice(0, take));
					remaining = remaining.slice(take);
				}
				continue;
			}
			if (buf.length + line.length > maxBody && buf) flush();
			buf += line;
		}
		flush();
		return parts.filter(Boolean).map((p) => `${open}${p}${close}`);
	};
	for (const seg of segments) {
		if (seg.kind === "text") {
			appendText(seg.content);
			continue;
		}
		if (seg.open.length + seg.body.length + seg.close.length > limit) {
			if (current) pushCurrent();
			const fenceChunks = splitFence(seg.open, seg.body, seg.close);
			for (const c of fenceChunks) {
				const out = c.replace(/[ ]+$/u, "");
				if (out) chunks.push(out);
			}
			continue;
		}
		const fenceText = `${seg.open}${seg.body}${seg.close}`;
		if (!current) {
			current = fenceText;
			continue;
		}
		if (current.length + fenceText.length <= limit) {
			current += fenceText;
			continue;
		}
		pushCurrent();
		current = fenceText;
	}
	if (current) pushCurrent();
	return chunks;
}
function findSplitPoint(text, limit) {
	if (limit >= text.length) return text.length;
	let searchStart = Math.floor(limit * 70 / 100);
	if (searchStart < 0) searchStart = 0;
	let window = text.slice(searchStart, limit);
	let idx = window.lastIndexOf("\n\n");
	if (idx !== -1) return searchStart + idx + 2;
	searchStart = Math.floor(limit * 60 / 100);
	if (searchStart < 0) searchStart = 0;
	window = text.slice(searchStart, limit);
	idx = window.lastIndexOf("\n");
	if (idx !== -1) return searchStart + idx + 1;
	searchStart = Math.floor(limit * 50 / 100);
	if (searchStart < 0) searchStart = 0;
	for (let i = limit - 1; i >= searchStart; i--) {
		const ch = text[i];
		if (ch === "." || ch === "!" || ch === "?") {
			const next = text[i + 1];
			if (next === void 0 || /\s/u.test(next)) return i + 1;
		}
	}
	searchStart = Math.floor(limit * 80 / 100);
	if (searchStart < 0) searchStart = 0;
	window = text.slice(searchStart, limit);
	idx = window.lastIndexOf(" ");
	if (idx !== -1) return searchStart + idx + 1;
	return limit;
}
function sendWithChunking(text, charLimit, sendFn) {
	const totalChars = text ? text.length : 0;
	const chunks = chunkText(text, charLimit);
	if (chunks.length === 0) return Promise.resolve({
		success: false,
		message_ids: [],
		chunks_sent: 0,
		total_chars: totalChars,
		error: {
			type: "content_rejected",
			message: "empty message",
			retry: false
		}
	});
	const messageIds = [];
	return (async () => {
		for (let i = 0; i < chunks.length; i++) {
			const chunk = chunks[i];
			try {
				const id = await sendFn(chunk);
				messageIds.push(id);
			} catch (err) {
				const msg = err instanceof Error ? err.message : String(err);
				return {
					success: false,
					message_ids: messageIds,
					chunks_sent: i,
					total_chars: totalChars,
					error: {
						type: "network",
						message: msg,
						retry: true
					}
				};
			}
		}
		return {
			success: true,
			message_ids: messageIds,
			chunks_sent: chunks.length,
			total_chars: totalChars
		};
	})();
}

//#endregion
//#region src/event.ts
var EventBuilder = class {
	event;
	constructor(platform, eventID) {
		this.event = {
			platform,
			event_id: eventID,
			timestamp: Date.now(),
			content: "",
			content_type: "text",
			account_id: "",
			sender_id: "",
			container_id: "",
			container_kind: "dm"
		};
	}
	withTimestamp(date) {
		this.event.timestamp = date.getTime();
		return this;
	}
	withTimestampUnixMs(ms) {
		this.event.timestamp = ms;
		return this;
	}
	withContent(content) {
		this.event.content = content;
		return this;
	}
	withContentType(contentType) {
		this.event.content_type = contentType;
		return this;
	}
	withSender(senderID, senderName) {
		this.event.sender_id = senderID;
		if (senderName) this.event.sender_name = senderName;
		return this;
	}
	withContainer(containerID, kind) {
		this.event.container_id = containerID;
		this.event.container_kind = kind;
		return this;
	}
	withPeer(peerID, kind) {
		this.event.container_id = peerID;
		this.event.container_kind = kind;
		return this;
	}
	withAccount(accountID) {
		this.event.account_id = accountID;
		return this;
	}
	withThread(threadID) {
		this.event.thread_id = threadID;
		return this;
	}
	withReplyTo(replyToID) {
		this.event.reply_to_id = replyToID;
		return this;
	}
	withAttachment(attachment) {
		if (!this.event.attachments) this.event.attachments = [];
		this.event.attachments.push(attachment);
		return this;
	}
	withMetadata(key, value) {
		if (!this.event.metadata) this.event.metadata = {};
		this.event.metadata[key] = value;
		return this;
	}
	build() {
		return this.event;
	}
};
function newEvent(platform, eventID) {
	return new EventBuilder(platform, eventID);
}

//#endregion
export { ADAPTER_CONTEXT_ENV_VAR, AdapterAccountSchema, AdapterCapabilitySchema, AdapterHealthSchema, AdapterInfoSchema, AdapterStreamStatusSchema, AttachmentSchema, ChannelCapabilitiesSchema, ContainerKindSchema, ContentTypeSchema, DeliveryErrorSchema, DeliveryErrorTypeSchema, DeliveryResultSchema, DeliveryTargetSchema, EventBuilder, NexusEventSchema, PeerKindSchema, SendRequestSchema, StreamEventSchema, chunkText, createAdapterLogger, emitStreamStatus, handleStream, loadAdapterRuntimeContext, newEvent, patchConsoleToStderr, pollMonitor, readAdapterRuntimeContextFile, requireAdapterRuntimeContext, runAdapter, runAdapter as runAdapterCLI, sendWithChunking };